{"version":3,"sources":["../webpack/bootstrap acb46fdbfb91c0c13e59","workers/getGeometry.worker.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AC7DA;AACA;AACA;AACA;;AAEA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,oCAAoC,4BAA4B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,0BAA0B,yBAAyB;AACnD;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ,GAAG,cAAc;AACzB;AACA,MAAM;AACN;AACA;AACA;AACA","file":"acb46fdbfb91c0c13e59.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/symphony-2/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap acb46fdbfb91c0c13e59","importScripts('https://www.gstatic.com/firebasejs/6.2.4/firebase-app.js')\r\nimportScripts('https://www.gstatic.com/firebasejs/6.2.4/firebase-firestore.js')\r\nimportScripts('https://www.gstatic.com/firebasejs/6.2.4/firebase-auth.js')\r\nimportScripts('https://www.gstatic.com/firebasejs/6.2.4/firebase-storage.js')\r\n\r\n// import SimplexNoise from 'simplex-noise'\r\n// import { map } from '../utils/math'\r\n// import Voronoi from 'voronoi'\r\n// import VoronoiTools from '../utils/VoronoiTools'\r\n// import seedrandom from 'seedrandom'\r\n// import * as THREE from 'three'\r\n\r\nlet config = {}\r\nlet docRefGeo\r\n// let planeSize\r\n\r\nself.addEventListener('message', async function (e) {\r\n  let data = e.data\r\n  switch (data.cmd) {\r\n    case 'get':\r\n\r\n      config = data.config\r\n      let blockData = data.blockData\r\n      // planeSize = data.planeSize\r\n\r\n      firebase.initializeApp(config.fireBase)\r\n\r\n      firebase.firestore()\r\n      const firebaseDB = firebase.firestore()\r\n      docRefGeo = firebaseDB.collection('bitcoin_blocks_geometry')\r\n\r\n      firebase.auth().signInAnonymously().catch(function (error) {\r\n        console.log(error.code)\r\n        console.log(error.message)\r\n      })\r\n\r\n      // check for data in cache\r\n      let blockRefGeo = docRefGeo.doc(blockData.hash)\r\n      let snapshotGeo = await blockRefGeo.get()\r\n\r\n      // let cacheData = !snapshotGeo.exists\r\n\r\n      // let blockGeoData\r\n      // if (cacheData) {\r\n      //   blockGeoData = await save(blockData)\r\n      // } else {\r\n      let rawData = snapshotGeo.data()\r\n\r\n      let offsetJSON = JSON.parse(rawData.offsets)\r\n      let offsetsArray = Object.values(offsetJSON)\r\n\r\n      let scalesJSON = JSON.parse(rawData.scales)\r\n      let scalesArray = Object.values(scalesJSON)\r\n\r\n      let blockGeoData = {\r\n        offsets: offsetsArray,\r\n        scales: scalesArray,\r\n        height: blockData.height\r\n      }\r\n      // }\r\n\r\n      blockGeoData.scales.forEach((scale, index) => {\r\n        data.scales[index] = scale\r\n      })\r\n\r\n      blockGeoData.offsets.forEach((offset, index) => {\r\n        data.offsets[index] = offset\r\n      })\r\n\r\n      delete blockGeoData.scales\r\n      delete blockGeoData.offsets\r\n\r\n      let returnData = {\r\n        blockGeoData: blockGeoData,\r\n        scales: data.scales,\r\n        offsets: data.offsets\r\n      }\r\n\r\n      self.postMessage(returnData, [\r\n        data.scales.buffer,\r\n        data.offsets.buffer\r\n      ])\r\n\r\n      break\r\n    case 'stop':\r\n      self.postMessage('WORKER STOPPED')\r\n      self.close()\r\n      break\r\n    default:\r\n      self.postMessage('Unknown command')\r\n  }\r\n}, false)\r\n\r\n// const save = async function (blockData) {\r\n//   // console.log('Block geo data: ' + blockData.hash + ' does not exist in the db, adding...')\r\n//   let pointCount = Math.max(blockData.n_tx, 4)\r\n\r\n//   const simplex = new SimplexNoise(blockData.height)\r\n\r\n//   const voronoi = new Voronoi()\r\n//   const voronoiTools = new VoronoiTools(voronoi, blockData.height, planeSize)\r\n\r\n//   let sites = []\r\n\r\n//   Math.seedrandom(blockData.height)\r\n\r\n//   for (let index = 0; index < pointCount; index++) {\r\n//     let found = false\r\n//     let x = 0\r\n//     let y = 0\r\n\r\n//     while (found === false) {\r\n//       x = Math.floor(Math.random() * planeSize - (planeSize / 2))\r\n//       y = Math.floor(Math.random() * planeSize - (planeSize / 2))\r\n\r\n//       let noiseVal = simplex.noise2D(x / 300, y / 300)\r\n\r\n//       if (((Math.random() * 5) * noiseVal) > -0.3) {\r\n//         let exists = false\r\n//         for (let existsIndex = 0; existsIndex < sites.length; existsIndex++) {\r\n//           const site = sites[existsIndex]\r\n//           if (site.x === x && site.y === y) {\r\n//             exists = true\r\n//             break\r\n//           }\r\n//         }\r\n//         if (!exists) {\r\n//           found = true\r\n//         }\r\n//       }\r\n//     }\r\n//     sites.push({x: x, y: y})\r\n//   }\r\n\r\n//   let voronoiDiagram = voronoi.compute(sites, {\r\n//     xl: -planeSize / 2,\r\n//     xr: planeSize / 2,\r\n//     yt: -planeSize / 2,\r\n//     yb: planeSize / 2\r\n//   })\r\n\r\n//   // work out network health\r\n//   let feeToValueRatio = 0\r\n//   if (blockData.outputTotal !== 0) {\r\n//     feeToValueRatio = blockData.fee / blockData.outputTotal\r\n//   }\r\n\r\n//   let blockHealth = map(feeToValueRatio, 0, 0.0001, 20, 0)\r\n//   if (blockHealth < 0) {\r\n//     blockHealth = 0\r\n//   }\r\n\r\n//   let relaxIterations = Math.round(blockHealth)\r\n\r\n//   if (blockData.n_tx > 1) {\r\n//     for (let index = 0; index < relaxIterations; index++) {\r\n//       try {\r\n//         voronoiDiagram = voronoiTools.relaxSites(voronoiDiagram)\r\n//       } catch (error) {\r\n//         console.log(error)\r\n//       }\r\n//     }\r\n//   }\r\n\r\n//   let offsets = new THREE.InstancedBufferAttribute(new Float32Array(blockData.n_tx * 2), 2)\r\n//   let scales = new THREE.InstancedBufferAttribute(new Float32Array(blockData.n_tx), 1)\r\n\r\n//   for (let i = 0; i < blockData.n_tx; i++) {\r\n//     // if (typeof blockData.tx[i] === 'undefined') {\r\n//     //   continue\r\n//     // }\r\n//     let cell = voronoiDiagram.cells[i]\r\n\r\n//     let site = new THREE.Vector2(cell.site.x, cell.site.y)\r\n\r\n//     // look at all adjacent cells and get the closest site to this site\r\n//     let minDistToSite = Number.MAX_SAFE_INTEGER\r\n\r\n//     cell.halfedges.forEach((halfEdge) => {\r\n//       if (halfEdge.edge.rSite !== null) {\r\n//         let distanceToSiteSq = new THREE.Vector2(halfEdge.edge.rSite.x, halfEdge.edge.rSite.y).distanceToSquared(site)\r\n//         if (distanceToSiteSq > 0) {\r\n//           minDistToSite = Math.min(minDistToSite, distanceToSiteSq)\r\n//         }\r\n//       }\r\n//       if (halfEdge.edge.lSite !== null) {\r\n//         let distanceToSiteSq = new THREE.Vector2(halfEdge.edge.lSite.x, halfEdge.edge.lSite.y).distanceToSquared(site)\r\n//         if (distanceToSiteSq > 0) {\r\n//           minDistToSite = Math.min(minDistToSite, distanceToSiteSq)\r\n//         }\r\n//       }\r\n//     })\r\n\r\n//     let radius = Math.sqrt(minDistToSite) * 0.5\r\n\r\n//     let planeXEdgeDist = (planeSize / 2) - Math.abs(site.x)\r\n//     let planeYEdgeDist = (planeSize / 2) - Math.abs(site.y)\r\n\r\n//     if (planeXEdgeDist < radius) {\r\n//       radius = planeXEdgeDist\r\n//     }\r\n//     if (planeYEdgeDist < radius) {\r\n//       radius = planeYEdgeDist\r\n//     }\r\n\r\n//     offsets.setXY(\r\n//       i,\r\n//       site.x,\r\n//       site.y\r\n//     )\r\n\r\n//     scales.setX(\r\n//       i,\r\n//       radius\r\n//     )\r\n//   }\r\n\r\n//   let geoData = {\r\n//     offsets: offsets.array,\r\n//     scales: scales.array\r\n//   }\r\n\r\n//   try {\r\n//     await docRefGeo.doc(blockData.hash).set({\r\n//       offsets: JSON.stringify(geoData.offsets),\r\n//       scales: JSON.stringify(geoData.scales),\r\n//       height: blockData.height\r\n//     }, { merge: true })\r\n//     console.log('Geo data for block: ' + blockData.hash + ' successfully written')\r\n//   } catch (error) {\r\n//     console.log('Error writing document: ', error)\r\n//   }\r\n//   return geoData\r\n// }\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/eslint-loader?{\"eslintPath\":\"C://repositories//symphony-2//node_modules//eslint//lib//api.js\"}!./src/workers/getGeometry.worker.js\n// module id = 0\n// module chunks = 0"],"sourceRoot":""}